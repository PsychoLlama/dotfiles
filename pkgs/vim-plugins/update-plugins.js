#!/usr/bin/env node

/**
 * Reads the list of vim plugins and generates a sort of lockfile, which is
 * then fed into `nixpkgs.vimUtils.buildVimPlugin`. Loosely based on the
 * update script from nixpkgs:
 * https://github.com/NixOS/nixpkgs/blob/a957776/pkgs/misc/vim-plugins/update.py
 *
 * This script is run manually. Be sure to enter a nix-shell beforehand.
 *
 * Formatting:
 * $ nix run nixpkgs.nodePackages.prettier -c prettier -w --single-quote
 */

const procs = require('child_process');
const os = require('os');
const fs = require('fs/promises');
const path = require('path');
const pluginNames = require('./plugin-names');

// How many git clones will be happening simultaneously.
const MAX_CONCURRENT_PROCESSES = os.cpus().length;
const LOCKFILE = path.join(__dirname, 'lockfile.json');

async function main() {
  const plugins = pluginNames.map(parseAsGhRepo);
  const manifest = await pinAllPluginVersions(plugins);
  const filePath = await writeManifestFile(manifest);
  process.stdout.write(filePath);
}

async function writeManifestFile(manifest) {
  const fileContents = formatAsJson({
    comment: 'DO NOT EDIT! This file was generated by ./update-plugins.js',
    plugins: manifest,
  });

  await fs.writeFile(LOCKFILE, fileContents);

  return LOCKFILE;
}

async function pinAllPluginVersions(plugins) {
  const queue = plugins.slice(); // This will be mutated.

  // This function runs recursively until all items in the queue are gone.
  // Calling it multiple times will spawn multiple "jobs".
  async function processConcurrently(isolatedPluginList) {
    if (queue.length === 0) return isolatedPluginList;

    const nextPlugin = queue.shift();
    console.error(
      `[${plugins.length - queue.length}/${plugins.length}] ${nextPlugin.repo}`
    );

    isolatedPluginList.push(await pinPluginVersion(nextPlugin));

    return processConcurrently(isolatedPluginList);
  }

  // The concurrency limit avoids rate limiting and CPU overburdening.
  const jobs = Array(MAX_CONCURRENT_PROCESSES)
    .fill()
    .map(() => processConcurrently([]));

  const pinnedPlugins = (await Promise.all(jobs)).flat();

  // Order is concurrent and non-deterministic. Sort roughly by name.
  return pinnedPlugins.sort((a, b) => (a.repo < b.repo ? -1 : 1));
}

async function pinPluginVersion(plugin) {
  const repository = `git@${plugin.domain}:${plugin.owner}/${plugin.repo}.git`;
  const homepage = `https://${plugin.domain}/${plugin.owner}/${plugin.repo}`;
  const { sha256, date, rev, url } = await prefetch(repository);
  const { owner, repo } = plugin;

  return {
    owner,
    repo,
    version: formatDateAsVersion(date),
    rev,
    hash: sha256,
    homepage,
  };
}

// Download the git repo, derive the nix hash, and determine a revision.
async function prefetch(repository) {
  const output = await cmd(
    'nix-prefetch-git',
    '--fetch-submodules',
    repository
  ).catch(() => {
    throw new Error(`Failed to clone ${repository}.`);
  });

  return JSON.parse(output);
}

// Asynchronously run a shell command.
async function cmd(name, ...args) {
  const proc = procs.spawn(name, args);
  const output = { stderr: Buffer.from([]), stdout: Buffer.from([]) };

  return new Promise((resolve, reject) => {
    proc.stdout.on('data', (data) => {
      output.stdout = Buffer.concat([output.stdout, data]);
    });

    proc.stderr.on('data', (data) => {
      output.stderr = Buffer.concat([output.stderr, data]);
    });

    proc.once('close', (exitCode) => {
      if (exitCode === 0) resolve(output.stdout.toString());
      else reject(new Error(output.stderr.toString()));
    });
  });
}

function formatAsJson(json) {
  return JSON.stringify(json, null, 2) + '\n';
}

// Assumes a structure of `owner/repo`.
function parseAsGhRepo(pluginPath) {
  const [owner, repo] = pluginPath.split('/');
  return { owner, repo, domain: 'github.com' };
}

// Trim the time off an ISO-8601. This serves as a plugin version.
function formatDateAsVersion(commitDate) {
  return commitDate.replace(/T.*/, '');
}

main();
